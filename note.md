- 丁寧にちゃんと考える
- 良い解が出る方針を探す

# 3/22

- 状態の持ち方
    - 領域と予約の対応
- 流石に焼くのが強そう
    - でも難しそう
- どういう分布？
    - 左に偏った分布ではある
    - ポアソン分布？

- なるべくパーテーションを共通して使いたい
    - どういう時に共通して使えるか？
        - 同じような面積なら使える
- 0日目にいいパーテーションを置きたい
- 違反はしない方が良さそう
    - `100(a-b)`なので、ほんの少しならしても良いかも
- 空きマスは0.25~25%
    - 2乗なので、難しいケースの方が多い
- 分割する時は、短い方の辺で分割するのが良い

# 3/23

- 長方形以外の形にするメリットはない
- ソートして小さい方（大きい方）からマッチングするのが最適
- それなりの貪欲を考えよう
    - 大きい方から詰める
    - seed=0を考える
    - i番目に大きいものの最大値を詰める？
    - ダメだったら、分割をしてみる

- スコア計算は？
    - O(D * N * log(N)) = 1e4
    - マッチングは一個ずれるだけなので、差分計算できそう
    - 割り当てられた領域（の最大値）を保持しておけば、違反チェックができる

- ビンパッキング問題
    - https://scmopt.github.io/opt100/68packing.html

- Nが大きいとブレが小さい、小さいとブレが大きい

## 貪欲

- 余っているところから可能な限り切り出す
- 先読みはとりあえずしない
- ビンを横にずらすのも必要そう

1. ビンを切り分ける
2. ビンパッキング問題を解く
    - 線は後で必要な時に切る

### 次のターンへの遷移

1. マッチングする
2. 違反していなければそのまま
3. 違反していれば、

- ビンをずらすと少しコストは増える（減る）
    - 伸びる方が多いと増える
    - ビンをずらすとコストが1000増えるので、しないか？
- 再帰的に区切るのは後で
- 後で辻褄合わせることはできそう
    - 領域の大小関係と位置関係はおおよそ一致する

- ビンの決め方は？
- 2つを統合して1つにして、1つを2つに分ける
- 可能な範囲を保持しておく
    - ビンごとに余裕を持っておく

- 状態の持ち方難しいね

```rust
/// [0, ..., W];
let bins: Vec<usize> = create_bins();

/// [Node, Node, ..., Node];
/// [
///     [node_idx, node_idx, node_idx],
///     [node_idx, node_idx],
///     [node_idx, node_idx, node_idx],
/// ];
let nodes: (Vec<Node>, Vec<Vec<usize>>) = create_nodes();
// let node_pool: Vec<usize>;

struct Node {
    sizes: Vec<usize>, // max_size:
    prev: usize,
    total_space: usize,
}
```

- binのswapをするなら、過去との照合も必要？
    - 新しいbinで過去のノードを置けるかどうかチェックする必要がある
    - 縮んだ後でswapする時が多そうだが、それを防ぐ必要がある
    - 縮めた後でも、大きさは保持する必要がある
- 復元は大変だが、出力する時に変換すれば良いだけ
    - Nodeを返せば良い
- sizesはreverseして結合できる
- 補完する時のマッチングは最適解が求まりそう
- 逆順？
- 木構造として保持するのが良いか？

1. ビンパッキング問題を解いて、初期状態を作成する
2. 領域の広さと予約面積の広さをマッチングさせる
    1. 領域の配列を作る
    2. 予約面積を逆順でソートする
    3. 1対1で対応させる
        - `a<=b`なら次へ
        - `a>b`なら、
            - 保持しているものがあって、そのまま使えるなら使う
            - 保持しているものがなければ
                - 1個先のが使えるなら、余分に使っているところを削る
                - 2つ組み合わせを探して、結合して新しいのを作る
                    - ビン間のswapも試す
                    - 現在のものは保持しておく

- マッチングの最適性の保証が全くない
    - 後から局所探索で改善できるか？
    - 後のことを考えた最適なマッチングを直接求めるのは無理そう
- 初期状態を最適化する？
    - ビームサーチ？
- binは固定しない方が良さそう
    - 少し足りないなら、ずらすだけで賄える

- どのビンにどの予約を入れるかを焼きなます
    - 仕切りの入れ方は貪欲に求まる？
    - 仕切りの切り替えを近傍として焼けそう
        - 縦方向にも適用しやすい
        - 幅が狭くなれば改善する
- 幅が狭いところの切り替えは多少多くても良い
    - 広いところが第一優先

## 方針

1. 頑張って縦横を管理する・割り当てを求める
2. 有向グラフとして表現する

- 切り替え回数の最小化、で良いのか？
    - きついケースでは満足にできないのでは？
    - 縦方向が必要なのでは？
- 大体はそれで良さそう
    - 縦方向はある程度必要そう

- Nが大きいときはビン数を多くできる

# 3/24

- 明日までに基本実装を終わらせたい
- 焼くためには？
    - 全部シミュレーションするしかない？
    - 操作を変更する近傍

- 初期状態を焼く
    - 一列の仕切りを調整する
        - 一つずらす
        - 全体的にうまく調整する
    - 仕切りを列単位で移動する
        - 一つ違う列に移動する
        - 仕切りを列ごと入れ替える
    - ビンを調整する
        - 一つをずらす
        - 全体的にうまく調整する
        - 一つを消す・足す
- 操作を焼く
    - 一つ仕切りを足して、一つ消す
        - シミュレーションしながら足す必要がある
    - 操作を打ち消す
- 違反がなくなるまで二乗誤差を目的関数として焼く

- 繰り返しビームサーチするとか？
    - 多分筋が良くない

- 仕切りを焼くのは解空間が広すぎる
- 予約の位置を焼く？
    - 順番を固定する？
    - 各列に入る予約だけを固定する？
        - 順番は最適な順番を求める

```rust
state: Vec<Vec<Vec<(usize, i64, i64)>>>

fn greedy(prev_r: &Vec<usize>, prev_h: &Vec<i64>, prev_rem: &Vec<i64>, next_r: &Vec<usize>, input: &Input, d: usize) {
    let mut next_h = vec![];
    let mut next_rem = vec![];

    let mut cur_prev_rem = prev_rem[0];
    let mut cur_next_rem = input.W - next_r.iter().map(|i| (input.A[d][i] + w - 1) / w).sum();
    let mut j = 0;
    let mut cur_prev_height = 0;
    let mut cur_next_height = 0;
    for i in 0..next_r.len() {
        cur_next_height += input.A[d][next_r[i]];
        while j < prev_r.len() && cur_prev_height + prev_h[j] < cur_next_height {
            cur_prev_height += prev_h[j];
            j += 1;
        }

        let use_prev_rem = cur_next_height - cur_prev_height;
        let use_next_rem = cur_prev_height + prev[j].1 - cur_next_height;

        let height = if cur_prev_rem >= use_prev_rem && cur_prev_rem - use_prev_rem >= cur_next_rem - use_next_rem {
            // 1. cur_prev_height < cur_next_height、prev_remを使う場合
            cur_prev_rem -= use_prev_rem;
            input.A[d][i]
        } else if cur_next_rem >= use_next_rem && cur_prev_rem - use_prev_rem <= cur_next_rem - use_next_rem {
            // 2. cur_prev_height + prev[j].1 > cur_next_height、next_remを使う場合
            cur_next_rem -= use_next_rem;
            c + use_next_rem
        } else {
            // 3. どちらも使えない場合
            use_next_rem
        };
        next_h.push(height);
        cur_prev_rem = prev_rem[j].min(cur_prev_rem);
    }
}
```

- 一個前が固定されている場合、使った余裕の最小値を持てばDPできる

# 3/25

- シミュレーションを繰り返す焼きなましよりはビームサーチが強いのでは、、？
- 以降の作りやすさを考慮できていないのでは？
    - 後から局所改善する
        - 一日を選んで、局所改善
    - 全体を最適化する
        - 後の解が良い保証がない限り無駄な気がする
    - 状態を複数保持して多様性を担保する
        - あり

## 解法

- 基本方針
    - 毎日焼きなましをして前日との切り替え回数が少ない配置を探す
- 状態
    - 日毎の予約の割り当て
        - 列ごとの予約の順番、確保している高さ、余裕を保持する
        - r, height, rem
    - 余裕
        - rem[i] := i番目の予約を使用するまでに使えるブロックの数
- 近傍
    - 列内の入れ替え
    - 列間の入れ替え
- 評価関数
    - 生スコア
    - タイブレークには全体の余裕
- 枝刈り
    - 列内の高さがWを超えたら棄却
- 初期解
    - 大きさの順番に対応させる
- 改善
    - 2日目を作る時には、1日目の配置も自由に入れ替えて良い
    - 余裕をたくさん使う場合は見送る、など
    - DPで解く
    - 反対方向からも最適化する

## ビンの幅

- 微妙に足りなくて損をすることはある？
    - 一行損をするくらいで、そんなに痛くないか？
- そもそもどういう幅が良いのか？
    - なるべく均等が良いのか、偏りがあると良いのか？
    - なるべく細長い方が良さそう
- 近傍
    - 列のマージ
    - 列の分割
    - 幅の入れ替え
    - 領域の移動
        - スワップ
        - 移動
- 目的関数
    - `はみ出した面積 * 100 - 列ごとの余裕`
    - だいぶ改善余地はある
    - 列に入っている個数・領域の一致具合
        - 個数、大きさの分布

```rust
fn create_initial_state() {
}

let bins = create_bins();

let mut r: Vec<Vec<Vec<(usize, i64)>>>
let mut rem: Vec<Vec<Vec<usize>>>

let state = create_initial_state();

for d in 1..input.D {
}
```

- arrよりarr[d]を渡した方が速いかも
- 一個前は、同じ根のノードなら入れ替えてOK？
    - だめ

# 3/27

### スケジュール

~3/28 データ構造を考える
~3/29 基本実装を終わらせる
~3/31 解法改善
~4/1  パラメータ調整

### 工夫

- DPで厳密に解く
- 列の配置を多様にする
    - 個数
- ビーム幅を調整する
    - 後半は太めに
    - 時間配分も調整する
- 評価関数
    - 余裕の総和ではなく、使える仕切りの数に応じて重み付けする
- 最初の配置は無条件で動かせる

## 方針

- 列を固定して、一日の切り替えコストを最小化する逐次最適化
- 状態
    - 現在の幅と余裕
    - ノードはusizeで管理
- データ構造
    - par[i] := ノードiの親
    - children[i] := ノードiの子供
    - rem[i] := ノードiの余裕
    - height[i] := ノードiの高さ
    - _rem[i] := ノードiの余裕（更新前）
    - _height[i] := ノードiの高さ（更新前）
    - pool := プールされているノード番号
- 近傍
    - 列内swap
    - 列間swap
- 実装手順
    - 焼きなましなし
    - 幅1の焼きなまし
    - ビームサーチ

# 3/29

- 3:3以上もちゃんと動いているか検証する
    - 最後がやはり怪しい
- return_remもちゃんと動いているか検証する
- prev_remは使う順番が決まっているので、タプルのキューで持てば良い
- parentを左から巡回していない

- 何もない列があると壊れる
    - 直前のノードを入れれば良い？

# 3/30

- 貪欲の改善
    - 余裕を使いすぎない方が良い
- 評価が重いので、なるべく良い近傍を選びたい

- 反対方向からも貪欲をする

## TODO

1. 配置改善パート
    - 近傍改善
        - スワップ対象
        - 列間swap、列内swap
    - 評価関数の改善
        - 余裕の量を考慮する
2. 列の作成パート
    - 近傍改善
        - スワップ対象
    - 評価関数の改善
        - 定義の見直し
        - 余裕の量を考慮する
3. ビームサーチ化
    - 時間管理
4. 貪欲ではなくDPにする
5. 高速化
    - ceil_divの前計算
    - 評価の高速化
    - `vec!`を消す
6. d=1の時だけ特別な処理をする
7. 含まれない列がある時用の対策

```
0000: {"score": 1767, "duration": 0.5999}
0001: {"score": 79109, "duration": 1.4540}
0002: {"score": 58941, "duration": 1.2562}
0003: {"score": 16336, "duration": 0.9790}
0004: {"score": 16844, "duration": 0.8490}
```

- 10倍高速化で1.15倍

## DONE:

- 余裕を消費する箇所は、rが小さい、lが大きい順
- 焼きなましをやめることを試してみる
- 反対から貪欲する
- 実現可能なbin_countを最小値にする

## 未検証

- swapは元の場所に戻さなくて良いのでは？
- 貪欲をbest-fitから変える

### 評価関数の改善

- optimize_start_cands
    - 高さを考慮する

- solve
    - 余裕を考慮する
    - 遷移しやすさを考慮する
        - 数が同じ？
        - 切り替え数が変わらないなら遷移した方が良い？

- 多点スタートでカバーするか、、

### 近傍効率の改善

- 幅を見る
    - インデックスが隣接するものをswapする
- 消せそうなやつを持ってくる
- prev_hとnext_hで仕切りが近くなるように動かす
- 多い方から少ない方に渡す
- 隣接swap
- 列間swap（位置未固定）

### ビームサーチ化

- ビーム幅の調整
    - Dを使う

### 高速化

- `fn match_greedy_fast() -> i64`

- wsの作り方は良いのか？
