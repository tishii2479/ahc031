- 丁寧にちゃんと考える
- 良い解が出る方針を探す

# 3/22

- 状態の持ち方
    - 領域と予約の対応
- 流石に焼くのが強そう
    - でも難しそう
- どういう分布？
    - 左に偏った分布ではある
    - ポアソン分布？

- なるべくパーテーションを共通して使いたい
    - どういう時に共通して使えるか？
        - 同じような面積なら使える
- 0日目にいいパーテーションを置きたい
- 違反はしない方が良さそう
    - `100(a-b)`なので、ほんの少しならしても良いかも
- 空きマスは0.25~25%
    - 2乗なので、難しいケースの方が多い
- 分割する時は、短い方の辺で分割するのが良い

# 3/23

- 長方形以外の形にするメリットはない
- ソートして小さい方（大きい方）からマッチングするのが最適
- それなりの貪欲を考えよう
    - 大きい方から詰める
    - seed=0を考える
    - i番目に大きいものの最大値を詰める？
    - ダメだったら、分割をしてみる

- スコア計算は？
    - O(D * N * log(N)) = 1e4
    - マッチングは一個ずれるだけなので、差分計算できそう
    - 割り当てられた領域（の最大値）を保持しておけば、違反チェックができる

- ビンパッキング問題
    - https://scmopt.github.io/opt100/68packing.html

- Nが大きいとブレが小さい、小さいとブレが大きい

## 貪欲

- 余っているところから可能な限り切り出す
- 先読みはとりあえずしない
- ビンを横にずらすのも必要そう

1. ビンを切り分ける
2. ビンパッキング問題を解く
    - 線は後で必要な時に切る

### 次のターンへの遷移

1. マッチングする
2. 違反していなければそのまま
3. 違反していれば、

- ビンをずらすと少しコストは増える（減る）
    - 伸びる方が多いと増える
    - ビンをずらすとコストが1000増えるので、しないか？
- 再帰的に区切るのは後で
- 後で辻褄合わせることはできそう
    - 領域の大小関係と位置関係はおおよそ一致する

- ビンの決め方は？
- 2つを統合して1つにして、1つを2つに分ける
- 可能な範囲を保持しておく
    - ビンごとに余裕を持っておく

- 状態の持ち方難しいね

```rust
/// [0, ..., W];
let bins: Vec<usize> = create_bins();

/// [Node, Node, ..., Node];
/// [
///     [node_idx, node_idx, node_idx],
///     [node_idx, node_idx],
///     [node_idx, node_idx, node_idx],
/// ];
let nodes: (Vec<Node>, Vec<Vec<usize>>) = create_nodes();
// let node_pool: Vec<usize>;

struct Node {
    sizes: Vec<usize>, // max_size:
    prev: usize,
    total_space: usize,
}
```

- binのswapをするなら、過去との照合も必要？
    - 新しいbinで過去のノードを置けるかどうかチェックする必要がある
    - 縮んだ後でswapする時が多そうだが、それを防ぐ必要がある
    - 縮めた後でも、大きさは保持する必要がある
- 復元は大変だが、出力する時に変換すれば良いだけ
    - Nodeを返せば良い
- sizesはreverseして結合できる
- 補完する時のマッチングは最適解が求まりそう
- 逆順？
- 木構造として保持するのが良いか？

1. ビンパッキング問題を解いて、初期状態を作成する
2. 領域の広さと予約面積の広さをマッチングさせる
    1. 領域の配列を作る
    2. 予約面積を逆順でソートする
    3. 1対1で対応させる
        - `a<=b`なら次へ
        - `a>b`なら、
            - 保持しているものがあって、そのまま使えるなら使う
            - 保持しているものがなければ
                - 1個先のが使えるなら、余分に使っているところを削る
                - 2つ組み合わせを探して、結合して新しいのを作る
                    - ビン間のswapも試す
                    - 現在のものは保持しておく

- マッチングの最適性の保証が全くない
    - 後から局所探索で改善できるか？
    - 後のことを考えた最適なマッチングを直接求めるのは無理そう
- 初期状態を最適化する？
    - ビームサーチ？
- binは固定しない方が良さそう
    - 少し足りないなら、ずらすだけで賄える

- どのビンにどの予約を入れるかを焼きなます
    - 仕切りの入れ方は貪欲に求まる？
    - 仕切りの切り替えを近傍として焼けそう
        - 縦方向にも適用しやすい
        - 幅が狭くなれば改善する
- 幅が狭いところの切り替えは多少多くても良い
    - 広いところが第一優先

## 方針

1. 頑張って縦横を管理する・割り当てを求める
2. 有向グラフとして表現する

- 切り替え回数の最小化、で良いのか？
    - きついケースでは満足にできないのでは？
    - 縦方向が必要なのでは？
- 大体はそれで良さそう
    - 縦方向はある程度必要そう

- Nが大きいときはビン数を多くできる

# 3/24

- 明日までに基本実装を終わらせたい
- 焼くためには？
    - 全部シミュレーションするしかない？
    - 操作を変更する近傍

- 初期状態を焼く
- 操作を焼く
- 違反がなくなるまで二乗誤差を目的関数として焼く
